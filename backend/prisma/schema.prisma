generator client {
  provider        = "prisma-client"
  output          = "../src/generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [vector]
}

// AUTHENTICATION MODELS


model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String
  name          String
  username      String    @unique
  avatarUrl     String
  emailVerified Boolean   @default(false)
  isAdmin       Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  refreshTokens           RefreshToken[]
  emailVerificationTokens EmailVerificationToken[]
  itineraries             UserItinerary[]
  
  // Social features
  sentFriendRequests     Friendship[]   @relation("FriendshipRequester")
  receivedFriendRequests Friendship[]   @relation("FriendshipAddressee")
  notifications          Notification[]
  conversationParticipants ConversationParticipant[]
  
  // Posts features
  posts    Post[]
  likes    Like[]
  comments Comment[]
  
  // Itinerary sharing
  sharedItineraries     ItineraryShare[] @relation("SharedItineraries")
  sentItineraryShares   ItineraryShare[] @relation("SentItineraryShares")
  userLocations         UserLocation[]   @relation("UserLocations")

  @@index([email])
  @@index([username])
}

model RefreshToken {
  id        String   @id @default(cuid())
  tokenHash String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  tokenHash String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model Friendship {
  id          String           @id @default(cuid())
  requesterId String
  requester   User             @relation("FriendshipRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  addresseeId String
  addressee   User             @relation("FriendshipAddressee", fields: [addresseeId], references: [id], onDelete: Cascade)
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@unique([requesterId, addresseeId])
  @@index([requesterId])
  @@index([addresseeId])
  @@index([status])
}

enum NotificationType {
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  POST_LIKE
  POST_COMMENT
  ITINERARY_SHARED
  ITINERARY_ACCEPTED
  TRIP_REMINDER
}

model Notification {
  id          String           @id @default(cuid())
  userId      String
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        NotificationType
  title       String
  message     String
  
  // Proper relations for post notifications
  postId      String?
  post        Post?            @relation("PostNotifications", fields: [postId], references: [id], onDelete: Cascade)
  commentId   String?
  comment     Comment?         @relation("CommentNotifications", fields: [commentId], references: [id], onDelete: Cascade)
  
  data        Json?            // Flexible payload (friendshipId, senderId, etc.)
  read        Boolean          @default(false)
  createdAt   DateTime         @default(now())

  @@index([userId])
  @@index([userId, read])
  @@index([createdAt])
  @@index([postId])
  @@index([commentId])
}

// MESSAGING MODELS

enum ConversationType {
  DIRECT    // 1:1 chat
  GROUP     // Group chat (future)
}

model Conversation {
  id            String           @id @default(cuid())
  type          ConversationType @default(DIRECT)
  name          String?          // For group chats (null for direct)
  imageUrl      String?          // Group avatar (future)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  
  participants  ConversationParticipant[]
  messages      Message[]
  
  @@index([updatedAt])
}

model ConversationParticipant {
  id              String       @id @default(cuid())
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId          String
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role            String       @default("MEMBER")  // ADMIN, MEMBER (for group management later)
  joinedAt        DateTime     @default(now())
  lastReadAt      DateTime     @default(now())
  
  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id              String       @id @default(cuid())
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId        String
  content         String
  createdAt       DateTime     @default(now())
  
  @@index([conversationId, createdAt])
  @@index([senderId])
}

enum LocationClassification {
  HIDDEN_GEM
  CONDITIONAL
  TOURIST_TRAP
  MUST_SEE
}


enum LocationCategory {
  RESTAURANT
  CAFE
  BAR
  NIGHTCLUB
  BEACH
  HIKING
  HISTORICAL_SITE
  MUSEUM
  MARKET
  VIEWPOINT
  PARK
  RELIGIOUS_SITE
  SHOPPING
  ACTIVITY
  HOTEL
  ACCOMMODATION
  OTHER
}

enum PriceLevel {
  INEXPENSIVE
  MODERATE
  EXPENSIVE
}



model Place {
  id                  String   @id @default(cuid())
  name                String
  classification      LocationClassification
  category            LocationCategory
  description         String
  
  // Source tracking
  sources             String[]  // ["reddit", "tripadvisor", "tiktok"]
  sourceUrls          String[]
  popularity          Int       @default(0)
  
  // Google Places enrichment
  googlePlaceId       String?   @unique
  rating              Float?
  totalRatings        Int?
  priceLevel          PriceLevel?
  openingHours        Json?     // Stored as JSON
  topReviews          Json?     // Top 3 reviews as JSON array
  
  // Location
  latitude            Float
  longitude           Float
  address             String?
  city                String    // City name for filtering
  country             String    @default("Lebanon")
  
  // Cost estimates (from sources)
  costMinUSD          Float?
  costMaxUSD          Float?
  
  // Metadata
  activityTypes       String[]  // ["food", "culture", "nature", etc]
  bestTimeToVisit     String?
  localTip            String?
  scamWarning         String?
  
  // Images and reviews from sources
  imageUrl            String?   // Primary image from TripAdvisor or Google
  imageUrls           String[]  // Multiple images
  sourceReviews       Json?     // Curated reviews from Reddit/TripAdvisor as JSON
  
  // Data freshness
  lastEnrichedAt      DateTime?
  lastValidatedAt     DateTime?
  
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  
  itineraryItems      ItineraryItem[]
  hotelDays           ItineraryDay[] @relation("DayHotel")
  
  @@index([classification])
  @@index([city])
  @@index([googlePlaceId])
  @@index([country])
  @@index([city, classification])
  @@index([country, category])
}

// Structured Itinerary for RAG and versioning
model UserItinerary {
  id                  String   @id @default(cuid())
  userId              String?
  user                User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Trip details
  country             String
  airportCode         String
  numberOfDays        Int
  budgetUSD           Float
  travelStyles        String[] // ["food", "culture", "nature"]
  
  // Flight info for notifications
  flightDate          DateTime?
  notificationsEnabled Boolean  @default(false)
  
  // Versioning
  version             Int      @default(1)
  
  // Generated output
  totalEstimatedCostUSD Float?
  routeSummary        String?
  
  // Timestamps
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  days                ItineraryDay[]
  checklist           ChecklistItem[]
  embeddings          ItineraryEmbedding[]
  shares              ItineraryShare[]   @relation("ItineraryShares")
  userLocations       UserLocation[]     @relation("ItineraryLocations")
  
  @@index([userId])
  @@index([flightDate])
  @@index([country])
}

model ItineraryDay {
  id            String   @id @default(cuid())
  
  itineraryId   String
  itinerary     UserItinerary @relation(fields: [itineraryId], references: [id], onDelete: Cascade)
  
  dayNumber     Int
  theme         String?       // "CULTURAL", "ADVENTURE", etc.
  description   String?       // "Exploring Beirut's historic downtown"
  
  // Hotel for this day (usually same across days)
  hotelId       String?
  hotel         Place? @relation("DayHotel", fields: [hotelId], references: [id])
  
  // Timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  items         ItineraryItem[]
  
  @@unique([itineraryId, dayNumber])
  @@index([itineraryId])
}

model ItineraryItem {
  id                  String   @id @default(cuid())
  
  orderInDay          Int
  
  // Duration and timing
  suggestedStartTime  String?  // "09:00"
  suggestedDuration   Int?     // minutes
  travelTimeFromPrev  Int?     // minutes
  
  // Item type for structured days
  itemType            ItineraryItemType @default(ACTIVITY)
  
  notes               String?
  
  dayId               String
  day                 ItineraryDay @relation(fields: [dayId], references: [id], onDelete: Cascade)
  
  placeId             String
  place               Place    @relation(fields: [placeId], references: [id], onDelete: Cascade)
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@unique([dayId, orderInDay])
  @@index([dayId])
  @@index([placeId])
}

enum ItineraryItemType {
  ACTIVITY
  BREAKFAST
  LUNCH
  DINNER
  SNACK
  EVENING
}

model ChecklistItem {
  id                  String   @id @default(cuid())
  
  category            ChecklistCategory
  item                String
  reason              String?  // Why this item is recommended
  source              String?  // "weather", "terrain", "activity", etc.
  
  isChecked           Boolean  @default(false)
  
  itineraryId         String
  itinerary           UserItinerary @relation(fields: [itineraryId], references: [id], onDelete: Cascade)
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@index([itineraryId])
  @@index([category])
}

enum ChecklistCategory {
  ESSENTIALS
  WEATHER
  TERRAIN
  ACTIVITY
  SAFETY
  DOCUMENTATION
}

// RAG Embeddings for itinerary Q&A
model ItineraryEmbedding {
  id              String   @id @default(cuid())

  itineraryId     String
  itinerary       UserItinerary @relation(fields: [itineraryId], references: [id], onDelete: Cascade)
  
  // Chunk info
  chunkIndex      Int
  chunkType       ChunkType
  chunkText       String     // Original text that was embedded
  
  // Metadata for filtering
  placeIds        String[]   // Place IDs referenced in this chunk
  dayNumbers      Int[]      // Days covered
  activityTypes   String[]   // Activity types in chunk
  
  // Vector embedding (1536 dimensions for OpenAI ada-002)
  embedding       Unsupported("vector(1536)")?
  
  // Legacy JSON field - will be removed after migration
  embeddingJson   Json?      @ignore
  
  createdAt       DateTime @default(now())
  
  @@index([itineraryId])
  @@index([chunkType])
}

model KnowledgeEmbedding {
  id              String   @id @default(cuid())
  
  content         String   // The actual text content
  countryCode     String   // ISO alpha-2 "LB"
  source          String   // "reddit", "wikipedia", etc.
  
  // Metadata like author, url, activityTypes, popularity
  metadata        Json?    
  
  // Vector embedding (1536 dimensions for OpenAI ada-002)
  embedding       Unsupported("vector(1536)")?
  
  // Legacy JSON field - will be removed after migration  
  embeddingJson   Json?    @ignore
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([countryCode])
  @@index([source])
}

enum ChunkType {
  FULL_SUMMARY
  DAY_PLAN
  PLACE_DETAIL
  CHECKLIST
  ROUTE_OVERVIEW
}

// ITINERARY SHARING MODELS

enum SharePermission {
  OWNER
  VIEWER
}

enum ShareStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model ItineraryShare {
  id           String          @id @default(cuid())
  itineraryId  String
  itinerary    UserItinerary   @relation("ItineraryShares", fields: [itineraryId], references: [id], onDelete: Cascade)
  
  userId       String
  user         User            @relation("SharedItineraries", fields: [userId], references: [id], onDelete: Cascade)
  
  permission   SharePermission @default(VIEWER)
  status       ShareStatus     @default(PENDING)
  
  invitedBy    String
  inviter      User            @relation("SentItineraryShares", fields: [invitedBy], references: [id], onDelete: Cascade)
  
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  
  @@unique([itineraryId, userId])
  @@index([userId])
  @@index([itineraryId])
  @@index([status])
}

model UserLocation {
  id                String        @id @default(cuid())
  userId            String
  user              User          @relation("UserLocations", fields: [userId], references: [id], onDelete: Cascade)
  
  itineraryId       String
  itinerary         UserItinerary @relation("ItineraryLocations", fields: [itineraryId], references: [id], onDelete: Cascade)
  
  latitude          Float
  longitude         Float
  accuracy          Float?        // meters
  heading           Float?        // degrees
  speed             Float?        // m/s
  
  lastUpdatedAt     DateTime      @default(now())
  createdAt         DateTime      @default(now())
  
  @@unique([userId, itineraryId])
  @@index([itineraryId])
  @@index([userId])
  @@index([lastUpdatedAt])
}

// POST/SOCIAL MODELS

enum PostVisibility {
  PUBLIC
  FRIENDS
  PRIVATE
}

model Post {
  id            String         @id @default(cuid())
  authorId      String
  author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  imageUrl      String
  description   String?
  visibility    PostVisibility @default(FRIENDS)
  
  // Counter fields for performance (avoid heavy joins)
  likesCount    Int            @default(0)
  commentsCount Int            @default(0)
  
  // Soft delete for moderation
  deletedAt     DateTime?
  
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  
  likes         Like[]
  comments      Comment[]
  notifications Notification[] @relation("PostNotifications")
  
  // Performance indexes for feed queries
  @@index([authorId, createdAt])
  @@index([visibility, createdAt])
  @@index([deletedAt])
}

model Like {
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  
  // Composite primary key prevents double likes and race conditions
  @@id([postId, userId])
  @@index([postId])
  @@index([userId])
}

model Comment {
  id            String         @id @default(cuid())
  postId        String
  post          Post           @relation(fields: [postId], references: [id], onDelete: Cascade)
  authorId      String
  author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  content       String
  
  // Soft delete for moderation
  deletedAt     DateTime?
  
  createdAt     DateTime       @default(now())
  
  notifications Notification[] @relation("CommentNotifications")
  
  // Performance indexes
  @@index([postId, createdAt])
  @@index([authorId])
  @@index([deletedAt])
}
